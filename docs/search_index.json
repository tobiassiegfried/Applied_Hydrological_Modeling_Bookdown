[["Chapter-DATA.html", "Chapter 3 Data Retrieval, Preparation &amp; Analysis", " Chapter 3 Data Retrieval, Preparation &amp; Analysis In this Chapter, we will discuss how to retrieve, prepare and process the data that is required for modeling. This includes in-situ station data, geospatial data, climate reanalysis data, and climate projections data. As will become clear, the preparation of these data requires a substantial amount of work, local storage space and, in some instances, computational power. With a focus on the generation of input files for hydrological-hydraulic modeling with RS Minerve, the flow diagram Figure ?? shows the required steps for the individual data types. These steps will be discussed in the individual Sections below in detail. "],["Data-StationData.html", "3.1 Station Data", " 3.1 Station Data Much of key data visualization techniques have already been presented in the Chapter 2. Here, we are demonstrating important data preparation steps that should always precede modeling. These preparatory steps focus on data cleaning and gap filling. 3.1.1 Available Data The riversCentralAsia Package provides available data of the gauging and meteorological stations in the Chirchik River Basin1. Before starting any type of modeling, it is important to get a good understanding of the data that we are dealing with and whether there exist problems with the raw data that need to be addressed prior to modeling. Problems usually include data gaps and outliers as data records that one obtains are usually ever complete nor clean of errors. The steps performed here are thus required steps for any type of successful modeling and should be performed with great care prior to starting hydrological modeling. We concentrate our efforts here on discharge records and data from meteorological stations in the Chirchik River Basin. The techniques shown here for decadal (10-days) data naturally extend to monthly data and also, to data from other basins. 3.1.2 Gap Filling Discharge Data In the following, we will work with decadal discharge data from the two main tributaries, i.e. the Chatkal and (Gauge 16279) Pskem rivers (Gauge 16290) and the data of the inflow to the Charvak reservoir (Gauge 16924). The goal is to analyze the data and prepare for modeling. First, let us load the relevant discharge data. data &lt;- ChirchikRiverBasin # load data q_dec_tbl &lt;- data %&gt;% filter(code == &#39;16279&#39; | code == &#39;16290&#39; | code == &#39;16924&#39;) # Note for the new name of the object, we choose to add periodicity (_dec_) and data type (_tbl for tibble/dataframe) to the data name. This just helps to stay organized and is good practice in R programming. q_dec_tbl ## # A tibble: 9,072 x 14 ## date data norm units type code station river basin resolution ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; ## 1 1932-01-10 48.8 38.8 m3s Q 16279 Khudaydod Chatkal Chirch… dec ## 2 1932-01-20 48.4 37.5 m3s Q 16279 Khudaydod Chatkal Chirch… dec ## 3 1932-01-31 42.4 36.6 m3s Q 16279 Khudaydod Chatkal Chirch… dec ## 4 1932-02-10 43.7 36.4 m3s Q 16279 Khudaydod Chatkal Chirch… dec ## 5 1932-02-20 44.2 36.3 m3s Q 16279 Khudaydod Chatkal Chirch… dec ## 6 1932-02-29 47.7 36.9 m3s Q 16279 Khudaydod Chatkal Chirch… dec ## 7 1932-03-10 54.1 39.4 m3s Q 16279 Khudaydod Chatkal Chirch… dec ## 8 1932-03-20 63.2 47.6 m3s Q 16279 Khudaydod Chatkal Chirch… dec ## 9 1932-03-31 103 60.5 m3s Q 16279 Khudaydod Chatkal Chirch… dec ## 10 1932-04-10 103 86.4 m3s Q 16279 Khudaydod Chatkal Chirch… dec ## # … with 9,062 more rows, and 4 more variables: lon_UTM42 &lt;dbl&gt;, ## # lat_UTM42 &lt;dbl&gt;, altitude_masl &lt;dbl&gt;, basinSize_sqkm &lt;dbl&gt; You can get more information about the available data by typing ?ChirchikRiverBasin. Note that the original time series data has been packaged in this format by the riversCentralAsia::loadTabularData() function which takes a simple .csv file as input. It is advisable to check at this stage for missing data in time series and to fill gaps where present. Are there missing data? How can these be filled so as to arrive at complete time series that are required for hydrological modeling? As can be seen in Figure 3.1 , close inspection of the time series indeed reveals some missing data in the 1940ies. q_dec_tbl %&gt;% plot_time_series(date,data, .facet_vars = code, .smooth = FALSE, .interactive = TRUE, .x_lab = &quot;year&quot;, .y_lab = &quot;m^3/s&quot;, .title = &quot;&quot; ) Figure 3.1: Discharge data of selected gauges in the upstream zone of runoff formation in the Chirchik River Basin. Data Source: Uzbek Hydrometeorological Service. Note, Figure 3.1 and the following Figures are interactive, so you can zoom in to regions of interest. Missing data are also confirmed by the warning that the function timetk::plot_time_series() throws (suppressed here). Statistics of the missing data can be easily obtained. As the Table below shows, we can do this analysis for each discharge station separately. q_dec_tbl %&gt;% group_by(code) %&gt;% summarize(n.na = sum(is.na(data)), na.perc = n.na/n()*100) ## # A tibble: 3 x 3 ## code n.na na.perc ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 16279 15 0.496 ## 2 16290 39 1.29 ## 3 16924 42 1.39 Summarizing the number of observation with missing data reveals 15 data points for station 16279 (0.5 % of total record length) and 39 for station 16290 (1.3 % of total record length). As there are only very few gaps in the existing time series, we use a simple method to fill these. Wherever there is a gap, we fill in the corresponding decadal norm as stored in the norm column in the object q_dec_tbl. The visualization of the results confirms that our simple gap filling approach is indeed satisfactory (Figure 3.2). q_dec_filled_tbl &lt;- q_dec_tbl q_dec_filled_tbl$data[is.na(q_dec_filled_tbl$data)] = q_dec_filled_tbl$norm[is.na(q_dec_filled_tbl$data)] # Gap filling step q_dec_filled_tbl %&gt;% plot_time_series(date, data, .facet_vars = code, .smooth = FALSE, .interactive = TRUE, .x_lab = &quot;year&quot;, .y_lab = &quot;m^3/s&quot;, .title = &quot;&quot; ) Figure 3.2: Gap filled Pskem and Chatkal river discharges. All missing data are gone now. q_dec_filled_tbl %&gt;% group_by(code) %&gt;% summarize(n.na = sum(is.na(data)), na.perc = n.na/n()*100) ## # A tibble: 3 x 3 ## code n.na na.perc ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 16279 0 0 ## 2 16290 0 0 ## 3 16924 0 0 A note of caution here. This simple gap filling technique reduces variance in the time series. It should only be used when the percentage of missing data is low. As will be discussed in the next Section 3.1.3 below, better techniques have to be utilized when there exist substantial gaps and in the case of less regular data. Finally, we discard the norm data which we used for gap filling of the missing discharge data and convert the data to wide format (see the Table below) to add to it meteorological data in the next Section. q_dec_filled_wide_tbl &lt;- q_dec_filled_tbl %&gt;% # again we use the name convention of objects as introduced above mutate(code = paste0(&#39;Q&#39;,code %&gt;% as.character())) %&gt;% # Since we convert everything to long form, we want to keep information as compact as possible. Hence, we paste the type identifier (Q for discharge here) in from of the 5 digit station code. dplyr::select(date,data,code) %&gt;% # ... and then ditch all the remainder information pivot_wider(names_from = &quot;code&quot;,values_from = &quot;data&quot;) # in order to pivot to the long format, we need to make a small detour via the wide format. q_dec_filled_long_tbl &lt;- q_dec_filled_wide_tbl %&gt;% pivot_longer(-date) # and then pivot back q_dec_filled_wide_tbl ## # A tibble: 3,024 x 4 ## date Q16279 Q16290 Q16924 ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1932-01-10 48.8 38.3 87.1 ## 2 1932-01-20 48.4 37.7 86.1 ## 3 1932-01-31 42.4 36.2 78.6 ## 4 1932-02-10 43.7 35.6 79.3 ## 5 1932-02-20 44.2 35 79.2 ## 6 1932-02-29 47.7 37.1 84.8 ## 7 1932-03-10 54.1 43.1 97.2 ## 8 1932-03-20 63.2 47 110 ## 9 1932-03-31 103 72.1 175 ## 10 1932-04-10 103 73.2 176 ## # … with 3,014 more rows As a result, we now have a complete record of decadal discharge data for the two main tributaries of the Chirchik river and the inflow time series to Charvak Reservoir from the beginning of 1932 until and including 2015, i.e. 84 years. The same type of preparatory analysis will now be carried out for the meteorological data. 3.1.3 Gap Filling Meteorological Data Here, we use precipitation and temperature data from Pskem (38462), Chatkal (38471) and Charvak Reservoir (38464) Meteorological Stations (see Chapter ?? for more information on these stations). We also have data from Oygaing station (Station Code 38339) but the record only starts in 1962 and the time resolution is monthly. Therefore, we do not take this station into account here for the time being. We start with precipitation and plot the available data. p_dec_tbl &lt;- data %&gt;% filter(type==&quot;P&quot; &amp; code!=&quot;38339&quot;) p_dec_tbl %&gt;% plot_time_series(date,data, .facet_vars = code, .interactive = TRUE, .smooth = FALSE, .title = &quot;&quot;, .y_lab = &quot;mm/decade&quot;, .x_lab = &quot;year&quot; ) Figure 3.3: Raw decadal precipitation data from Pskem (38462), Charvak Reservoir (38471) and Chatkal Meteo Station (38471). The precipitation data from these 3 stations shows some significant data gaps. The Chatkal Meteorological Station that is located in Kyrgyzstan apparently did not work in the post-transition years and continuous measurements were only resumed there in 1998. Let us see what happens if we were to use the same simple gap filling technique that we introduced above for discharge. p_dec_filled_tbl &lt;- p_dec_tbl p_dec_filled_tbl$data[is.na(p_dec_filled_tbl$data)] = p_dec_filled_tbl$norm[is.na(p_dec_filled_tbl$data)] p_dec_filled_tbl %&gt;% plot_time_series(date,data, .facet_vars = code, .interactive = TRUE, .smooth = FALSE, .title = &quot;&quot;, .y_lab = &quot;mm/decade&quot;, .x_lab = &quot;year&quot; ) Figure 3.4: Precipitation Data gap-filled with norms. The filled values from 1990 - 2000 in the case of the Station 38471 indicate that the norm-filling technique is not good. Closely inspect the significant data gap in the 1990ies at Station 38741 (tip: play around and zoom into the time series in the 1990ies in Figure 3.3 and comparing it with the resulting gap-filled timeseries in Figure ??. We see that our technique of gap filling with long-term norms is not suitable for this type of data and the significant gap size. The effect of variance reduction is also clearly visible. Hence, we resort to a more powerful gap filling technique that uses a (regression) model to impute the missing values from existing ones at the neighboring stations, i.e. Stations 38462 and 38464. To do so, we utilize the simputation R package that is tightly integrated in the tidyverse2. library(simputation) # First, we bring the data into the suitable format. p_dec_wide_tbl &lt;- p_dec_tbl %&gt;% mutate(code = paste0(&#39;P&#39;,code %&gt;% as.character())) %&gt;% dplyr::select(date,data,code) %&gt;% pivot_wider(names_from = &quot;code&quot;,values_from = &quot;data&quot;) # Second, we impute missing values. p_dec_filled_wide_tbl &lt;- p_dec_wide_tbl %&gt;% impute_rlm(P38471 ~ P38462 + P38464) %&gt;% # Imputing precipitation at station 38471 using a robust linear regression model impute_rlm(P38462 ~ P38471 + P38464) %&gt;% # Imputing precipitation at station 38462 using a robust linear regression model impute_rlm(P38464 ~ P38462 + P38471) # Imputing precipitation at station 38464 using a robust linear regression model p_dec_filled_long_tbl &lt;- p_dec_filled_wide_tbl %&gt;% pivot_longer(c(&#39;P38462&#39;,&#39;P38464&#39;,&#39;P38471&#39;)) p_dec_filled_long_tbl%&gt;% plot_time_series(date,value, .facet_vars = name, .interactive = TRUE, .smooth = FALSE, .title = &#39;&#39;, .y_lab = &quot;mm/decade&quot;, .x_lab = &quot;year&quot; ) Figure 3.5: Precipitation Data gap filled with a robust linear regression modeling approach As you can see, we use simple linear regression models to impute missing value in the target time series using observations from the neighboring stations. Through simple visual inspection, it becomes clear that this type of regression model for gap filling is better suited than the previous approach chosen. Let us check whether we could successfully fill all gaps with this robust linear regression approach. p_dec_filled_long_tbl %&gt;% group_by(name) %&gt;% summarize(n.na = sum(is.na(value)), n.na.perc = n.na/n()*100) ## # A tibble: 3 x 3 ## name n.na n.na.perc ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 P38462 12 0.402 ## 2 P38464 12 0.402 ## 3 P38471 3 0.100 It turns out that we still have very few gaps to deal with. We can see them by simply visualizing the wide tibble. The problem persisted at times when two or more values were missing across the available stations at the same time and where thus the linear regression could not be carried out. p_dec_filled_wide_tbl %&gt;% head(10) ## # A tibble: 10 x 4 ## date P38462 P38464 P38471 ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1933-01-10 NA NA 2 ## 2 1933-01-20 NA NA 10 ## 3 1933-01-31 NA NA 5 ## 4 1933-02-10 NA NA 33 ## 5 1933-02-20 NA NA 8 ## 6 1933-02-28 NA NA 10 ## 7 1933-03-10 NA NA 31 ## 8 1933-03-20 NA NA 50 ## 9 1933-03-31 NA NA 6 ## 10 1933-04-10 23 21.3 13 p_dec_filled_wide_tbl %&gt;% tail() ## # A tibble: 6 x 4 ## date P38462 P38464 P38471 ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2015-11-10 72 81 19 ## 2 2015-11-20 122 76 43 ## 3 2015-11-30 7 2 3 ## 4 2015-12-10 NA NA NA ## 5 2015-12-20 NA NA NA ## 6 2015-12-31 NA NA NA We can solve the issues related to the missing values at the start of the observation record by using the same technique as above and by only regressing P38462 and P38464 on P38471. p_dec_filled_wide_tbl &lt;- p_dec_filled_wide_tbl %&gt;% impute_rlm(P38462 ~ P38471) %&gt;% # Imputing precipitation at station 38462 using a robust linear regression model impute_rlm(P38464 ~ P38471) # Imputing precipitation at station 38464 using a robust linear regression model p_dec_filled_wide_tbl %&gt;% head(10) ## # A tibble: 10 x 4 ## date P38462 P38464 P38471 ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1933-01-10 5.60 5.08 2 ## 2 1933-01-20 18.3 16.7 10 ## 3 1933-01-31 10.4 9.46 5 ## 4 1933-02-10 54.9 50.3 33 ## 5 1933-02-20 15.2 13.8 8 ## 6 1933-02-28 18.3 16.7 10 ## 7 1933-03-10 51.8 47.3 31 ## 8 1933-03-20 82.0 75.0 50 ## 9 1933-03-31 12.0 10.9 6 ## 10 1933-04-10 23 21.3 13 Converse to this, the complete set of observations is missing for December 2015. We will thus remove these non-observations from our tibble. p_dec_filled_wide_tbl &lt;- p_dec_filled_wide_tbl %&gt;% na.omit() p_dec_filled_wide_tbl %&gt;% tail() ## # A tibble: 6 x 4 ## date P38462 P38464 P38471 ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2015-10-10 5 1 0 ## 2 2015-10-20 89 108 58 ## 3 2015-10-31 34 40 12 ## 4 2015-11-10 72 81 19 ## 5 2015-11-20 122 76 43 ## 6 2015-11-30 7 2 3 p_dec_filled_long_tbl &lt;- p_dec_filled_wide_tbl %&gt;% pivot_longer(-date) Inspecting the temperature data, we see similar data issues as in the precipitation data set. t_dec_tbl &lt;- data %&gt;% filter(type==&quot;T&quot;) t_dec_tbl %&gt;% plot_time_series(date,data, .facet_vars = code, .interactive = TRUE, .smooth = FALSE, .title = &#39;&#39;, .y_lab = &quot;deg. Celsius&quot;, .x_lab = &quot;year&quot; ) (#fig:rawData_T)Raw temperature data from the meteorological stations Pskem (38462) and Chatkal (38471) # First, we bring the data into the suitable format. t_dec_wide_tbl &lt;- t_dec_tbl %&gt;% mutate(code = paste0(&#39;T&#39;,code %&gt;% as.character())) %&gt;% dplyr::select(date,data,code) %&gt;% pivot_wider(names_from = &quot;code&quot;,values_from = &quot;data&quot;) # Second, we impute missing values. t_dec_filled_wide_tbl &lt;- t_dec_wide_tbl %&gt;% impute_rlm(T38471 ~ T38462) %&gt;% # Imputing precipitation at station 38471 using a robust linear regression model impute_rlm(T38462 ~ T38471) # Imputing precipitation at station 38462 using a robust linear regression model t_dec_filled_long_tbl &lt;- t_dec_filled_wide_tbl %&gt;% pivot_longer(c(&#39;T38462&#39;,&#39;T38471&#39;)) t_dec_filled_long_tbl%&gt;% plot_time_series(date,value, .facet_vars = name, .interactive = TRUE, .smooth = FALSE, .title = &#39;&#39;, .y_lab = &quot;deg. Celsius&quot;, .x_lab = &quot;year&quot; ) (#fig:rawData_T_rlm)Temperature data gap filled with robust linear regression modeling. There are some irregularities in the temperature time series of Chatkal Meteorological Station in the first decade of the 20th century (tip: zoom in to see these more clearly). Note that these were not introduced by the gap filling technique that we used but are most likely wrong temperature readings. We will return to these in the outlier analysis below in Section 3.1.4. t_dec_filled_long_tbl %&gt;% group_by(name) %&gt;% summarize(n.na = sum(is.na(value)), n.na.perc = n.na/n()*100) ## # A tibble: 2 x 3 ## name n.na n.na.perc ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 T38462 3 0.100 ## 2 T38471 3 0.100 To see where the missing value are, we find them easily again by looking at the head and tail of the tibble. t_dec_filled_wide_tbl %&gt;% head() ## # A tibble: 6 x 3 ## date T38462 T38471 ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1933-01-10 -6.9 -16.6 ## 2 1933-01-20 -6.1 -15.5 ## 3 1933-01-31 -6.3 -15.6 ## 4 1933-02-10 -2 -8.6 ## 5 1933-02-20 -3.3 -12.5 ## 6 1933-02-28 -0.1 -8.5 t_dec_filled_wide_tbl %&gt;% tail() ## # A tibble: 6 x 3 ## date T38462 T38471 ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2015-11-10 2.4 -2.5 ## 2 2015-11-20 2 -2.2 ## 3 2015-11-30 4.6 -3.7 ## 4 2015-12-10 NA NA ## 5 2015-12-20 NA NA ## 6 2015-12-31 NA NA Finally, we remove the non observations again as above with the function na.omit. t_dec_filled_wide_tbl &lt;- t_dec_filled_wide_tbl %&gt;% na.omit() t_dec_filled_long_tbl &lt;- t_dec_filled_wide_tbl %&gt;% pivot_longer(-date) To deal with the missing values at the end of the observational record, we could also have used any other technique. Using the norm values however would have artificially reduced the variance in both cases as explained above. Furthermore and at least in the case of temperature, it is also questionable to what extent a norm calculated over the last 84 years is still representative given global warming. We will look in this important and interesting topic in the next section. 3.1.4 Anomalies and Outliers We use the function timetk::plot_anomaly_diagnostics to investigate anomalies in the time series. For discharge, we first log-transform the raw data with the following transformation to reduce the variance of the original data. \\[ \\hat{q}(t) = log(q(t) + 1) \\] where \\(\\hat{q}(t)\\) denotes the transformed discharge. Prior to the log transformation, 1 is added so as to avoid cases where discharge would be 0 and the logarithmic transform thus undefined. The transformation can easily be done with the log1p() function in R. Backtransformation via the function expm1() simply involves taking the exponent and subtracting 1 from the result. Figure ?? shows the result. The exceptionally wet year 19169 shows up as anomalous in the Chatkal River Basin and at the downstream Charvak Reservoir inflow gauge. , ?? and ?? show anomalies diagnostics of the available data. q_dec_filled_long_tbl %&gt;% plot_anomaly_diagnostics(date, value %&gt;% log1p(), .facet_vars = name, .frequency = 36, .interactive = TRUE, .title = &quot;&quot;) Figure 3.6: Anomaly diagnostics of discharge data. The transparent grey band shows the width of the normal range. The highly anomalous wet year of 1969 is clearly visible in the discharge record of the Chatkal river basin (Station 16279). The investigation of precipitation anomalies shows a succession of regular anomalous wet events over time. It is interesting to see that the winter 1968/69 regularly anomalous at all three stations (Figure 3.7, zoom in to investigate). p_dec_filled_long_tbl %&gt;% plot_anomaly_diagnostics(date, value, .facet_vars = name, .interactive = TRUE, .title = &quot;&quot;) Figure 3.7: Anomaly diagnostics of precipitation data. While intuitively, we would have expected an eceptionally mild winter in 1968/69 due to the precipitation excess, the corresponding anomaly does not show up in the temperature record (Figure 3.8). t_dec_filled_long_tbl %&gt;% plot_anomaly_diagnostics(date,value, .facet_vars = name, .interactive = TRUE, .title = &quot;&quot;) Figure 3.8: Anomaly diagnostics of temperature data. Apart from the identification of extremal periods since as the 1969 discharge year in the Chatkal river basin, the diagnostics of anomalies also helps to identify likely erroneous data records. In Figure @ref(anomalies_T) for example, when we zoom into the data of the series T38471 in the first decade of the 21st century, problems in relation to positive anomalies during the winter are visible in 4 instances. One explanation would be that in at least some instances, the data are erroneously recorded as positive values when in fact they were negative (see dates ‘2002-01-31,’ ‘2005-01-10’ and ‘2007-02-28,’ Chatkal Station 38471). 3.1.5 Putting it all together Finally, we are now in the position to assemble all data that we will use for empirical modeling. The data is stored in long and wide form and used accordingly where required. For example, in Section @ref{TimeSeriesReg}, we are working with the wide data format to investigate model features in linear regression. Note that we also add a column with a decade identifier. Its use will become apparent in the Section 5.5 below. # Final concatenation data_wide_tbl &lt;- right_join(q_dec_filled_wide_tbl,p_dec_filled_wide_tbl,by=&#39;date&#39;) data_wide_tbl &lt;- right_join(data_wide_tbl,t_dec_filled_wide_tbl,by=&#39;date&#39;) # Add period identifiers (decades in this case) s &lt;- data_wide_tbl$date %&gt;% first() e &lt;- data_wide_tbl$date %&gt;% last() decs &lt;- decadeMaker(s,e,&#39;end&#39;) decs &lt;- decs %&gt;% rename(per=dec) data_wide_tbl &lt;- data_wide_tbl %&gt;% left_join(decs,by=&#39;date&#39;) # Creating long form data_long_tbl &lt;- data_wide_tbl %&gt;% pivot_longer(-date) # Cross checking completeness of record data_long_tbl %&gt;% group_by(name) %&gt;% summarize(n.na = sum(is.na(value)), n.na.perc = n.na/n()*100) ## # A tibble: 9 x 3 ## name n.na n.na.perc ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 P38462 0 0 ## 2 P38464 0 0 ## 3 P38471 0 0 ## 4 per 0 0 ## 5 Q16279 0 0 ## 6 Q16290 0 0 ## 7 Q16924 0 0 ## 8 T38462 0 0 ## 9 T38471 0 0 A consistent data record from 1933 until and including November 2015 is now prepared^Please note that by using left_join above, we have cut off discharge data from the year 1932 since we do not have meteorological data there.^. Let us analyze these data now. Where other data are used, their source and access options are indicated.↩︎ Please note that if you do not have the required package installed locally, you should install it prior to its use with the following command install.packages('simputation')↩︎ "],["Data-GeospatialData.html", "3.2 Geospatial Data", " 3.2 Geospatial Data This Section follows the steps shown in Figure ?? and explains in a hands-on manner how to arrive at and process the required geospatial data for later inclusion in the hydrological-hydraulic model RS MINVERVE. Links to detailed descriptions of the individual tasks allow even beginners of QGIS to follow the procedure. 3.2.1 Setting up QGIS Open and save a new QGIS project (How to for absolute beginners). Make sure that the maps projection is in UTM (How to change the projection of a project). The needed plugins are: qProf or profile tool (How to install and activate a plugin). The optional plugins are: SRTM plugin (requires a login to USGS Earth Explorer How to register). Note, SAGA routines must be installed and correctly configured in QGIS. 3.2.2 Load DEM We use the SRTM 1 arc-second global DEM (Data description). The DEM tiles are downloaded directly in QGIS3 (SRTM plugin, How to) or via the USGS Earth Explorer (How to) and merged to a single GIS layer (How to). In any case you will need to register for an Earth Explorer account How to register. 3.2.3 Derive the boundaries of your catchment If you already have a shapefile for the boundaries of your catchment. Load it into QGIS How to add a vector layer. Otherwise, follow this tutorial on youtube to derive the boundaries of your catchment. 3.2.4 Run through the process model A process model is available that generates the raw GIS layers for RS Minerve. Navigate to Processing and open the Graphical Modeller…. The Model Designer window opens. Open the model Link to Model (3.9). Figure 3.9: The process of deriving the GIS layers for RS Minerve is simplified through the process model. *TODO: Make file available for download. Prior to running the model, read through the following brief notes. 3.2.4.1 Input files A shape file of the basin outline in UTM 42 N (How to derive the basin outline). The extent of the DEM needs to be larger than the boundaries of your catchment. You can use your raw SRTM DEM projected to UTM42N. 3.2.4.2 Model output Besides the 3 layers required (Basins, rivers, junctions, ?? in the Introduction), the model produces a number of additional output files which can be used for verifying the parameterisation which is described in more detail in the next section. 3.2.4.3 Parameterization of the model BasinShapeBuffer_meters is a buffer around the basin outline to which the DEM is cut. The DEM needs to be slightly larger than the shape line. The default value of 1000 m is sufficient. Can this parameter be internalised? River Network Level is a parameters for the resolution of the river network. Values of 7 and 8 have shown good results for smaller and medium sized catchments (3.10). Figure 3.10: Comparison of River Network Level = 7 (left) and River Network Level = 8 (rigth) for the example of the Pskem river catchment. The Channel Network Cutoff Value is a parameter required for the partitioning of the catchment into sub-catchments. Values between 2e8 and 5e8 have been found to work well for smaller and medium sized catchments. The model is sensitive to this parameter and might throw an error if the cutoff value is not appropriate. The Elevation Bands Table holds the altitude boundaries and class IDs for the elevation bands in the catchment. After a first test run, edit according to your needs. The model is sensitive to these parameters. Play around with them until you are satisfied with the resulting GIS layers. If you get an error message running Fix geometries that POLYGONS.shp was not found, try reducing the Channel Network Cutoff Value by 50-70%. You can still inspect the other layers and change other parameters as well. - Make sure that all input layers are projected to UTM 42 N. - Run the model through once, inspect the output and play with the input parameters: - Min and Max elevations on the smoothed DEM and the shape, number and spacing of elevation bands (edit the table for the elevation bands accordingly), - Location and shape of river reaches and the location of junctions (vary the threshold). 3.2.5 Manually edit the GIS Layers for import to RS Minerve Review ?? Elevation bands per sub-basin need to be in one Multi-Polygon layer. We need junctions only at the confluences of sub-basins (and river reaches). We only need river reaches where we need to do routing. The sub-basins at the upper-most reaches do not need river reaches. 3.2.5.1 Edit Junctions layer Select the Junctions layer and toggle manual editing by clicking on the yellow pen (3.11). Figure 3.11: Manually edit the layer with the river junctions, step 1: Toggle layer editing. When in editing mode, the yellow pen will appear in the Layers window next to the name of the layer being edited. The edit mode will also activate a button for adding points (i.e. junctions, we don’t need that now) and the vertex tool. Click on the vertex tool icon. It is active when a a boundary appears around the icon and the Vertex Editor windows opens (3.12). Figure 3.12: Manually edit the layer with the river junctions, step 2: Activate the vertex tool. Right-click on a junction point you would like to delete to activate it (3.13). Figure 3.13: Manually edit the layer with the river junctions, step 3: Activate a junction node for editing. Select the activated point by drawing a rectangle over the point with your mouse. The point will appear blue (3.14). Figure 3.14: Manually edit the layer with the river junctions, step 3: Select the activated junction node. Delete the point with the delete key on your keyboard. You can save your edits by pressing the blue-white Save Layer Edits button that is decorated with an orange pen (3.15). This saves your changes without exiting the edit mode. Figure 3.15: Manually edit the layer with the river junctions, step 3: Save edits. If you have many points to remove, as in our case, it may be faster to identify the IDs of the features you want to keep, select these and delete all others. To start, you activate the Identify Features mode by clicking on the icon with the white i on the blue circle (3.16). Figure 3.16: Alternative method to manually edit junctions if many nodes need to be deleted. Step 1: Get ID of features to keep, part 1. A black i will appear next to your cursor. You then click on the first of your nodes that you want to keep. This will highlight it in red and a list with information on the selected feature appears on the right in the Identify Results window. You will see the attribute NODE_ID with value 1 for the outflow node (3.17). Note down the ID of the feature. Figure 3.17: Alternative method to manually edit junctions if many nodes need to be deleted. Step 1: Get ID of features to keep, part 2. You then press on the node at the confluence of the two tributaries in the center of the catchment. The Identify Results window shows 2 results, that means, that two junction nodes are close to each other (3.18). Figure 3.18: Alternative method to manually edit junctions if many nodes need to be deleted. Step 1: Get ID of features to keep, part 3. Zoom in in your map window with your mouse to see the two nodes (3.19). Figure 3.19: Alternative method to manually edit junctions if many nodes need to be deleted. Step 1: Get ID of features to keep, part 4. Select the node that should be kept and not the ID of the node (NODE_ID 11), (3.20). Figure 3.20: Alternative method to manually edit junctions if many nodes need to be deleted. Step 1: Get ID of features to keep, part 5. Zoom back to the entire Junctions layer (see ??). and go to Select Features by Values… in the toolbar (3.21). Figure 3.21: Alternative method to manually edit junctions if many nodes need to be deleted. Step 2: Select features to delete, part 1 Add NODE_ID 1 to your selection as demonstrated in (3.22). Figure 3.22: Alternative method to manually edit junctions if many nodes need to be deleted. Step 2: Select features to delete, part 2 The outflow node with ID 1 will change color in your map (3.23). Figure 3.23: Alternative method to manually edit junctions if many nodes need to be deleted. Step 2: Select features to delete, part 3 Add node 11 to your selection in the same way and close the Select Node by Value window. Invert the feature selection as shown in (3.24). Figure 3.24: Alternative method to manually edit junctions if many nodes need to be deleted. Step 2: Select features to delete, part 4 All other nodes will now be yellow and the ones to keep will appear in the layer color (3.25). Figure 3.25: Alternative method to manually edit junctions if many nodes need to be deleted. Step 2: Select features to delete, part 5 Delete the features (nodes) by pressing the Delete Selected button in the edit features toolbar (3.26). Figure 3.26: Alternative method to manually edit junctions if many nodes need to be deleted. Step 2: Select features to delete, part 6 Save your edits (3.15). To verify that, indeed, all superfluous nodes are deleted from the Junctions file, open the Attribute table (3.27). Figure 3.27: Edit Attribute table. Step 1: Open the attribute table with a click on the Attribute Table icon in the QGIS toolbar. Only 2 features should be listed under each attribute. We will now edit the attribute table to prepare it for the RS Minerve model (see ??). RS Minerve needs an identifyer to differentiate between the junctions. We can use the attribute TYPE to uniquely identify the two junctions needed. RS Minerve further needs the ID of the downstream river. Add a collumn to the attribute table by pressing the Add Field button (3.28). Figure 3.28: Edit Attribute table. Step 2: Add a column to the attribute table manually, part 1. Define a name for the attribute, a type and admissible length of each entry in the Add Field window. In our case, we choose a string (a word) as ID and allow it to be 20 characters long (3.29). Figure 3.29: Edit Attribute table. Step 2: Add a column to the attribute table manually, part 2. Close the window by pressing OK. By clicking in the newly created NULL fields, you can now type names for the downstream rivers and save your edits by pressing the save edits icon (3rd from the left in the toolbar of the attribute table window). As the outlet of the catchment goes directly into Charvak reservoir, we can type Charvak as the downstream river ID. The river stretch between junction and outlet is called Pskem (3.30). Figure 3.30: Edit Attribute table. Step 2: Add a column to the attribute table manually, part 3. We are done editing the Junctions layer. Deactivate the edit mode by clickig on the yellow pen in the attribute table window (3.31) and close the window. Figure 3.31: Save your edits. Now save the Junctions layer in an appropriate place on your drive and save your project. 3.2.5.2 Edit Channels layer Proceed in the same way as for the junctions: Delete channel sections that are not needed in the Minerve model. "],["Data-ClimateReanalysisData.html", "3.3 Climate Reanalysis Data", " 3.3 Climate Reanalysis Data Information about the spatio-temporal distribution of precipitation (P) and temperature (T) is vital for water balance studies, including for modeling. Poorly gauged basins do not have dense enough ground-based monitoring network that would allow to obtain reliable meteorological fields that can be used to drive hydrological models. Station data are especially poor in complex and remote mountain catchments in developing and transition countries. The Central Asian river basins are examples of such basins. Global reanalysis data can help to cover these existing gaps. In this Chapter, we show how this can be achieved. We use ERA5 global reanalysis data to obtain temperature at 2 meters above ground and total precipitation fields on an hourly base from 1981-01-01 through 2020-12-31. ERA5 data comes with a 30km grid cell size resolution and is thus quite course. This is relevant for complex mountain terrains which feature highly variable climate over very short distances, sometimes from one valley to the next. To address this problem, a bias correct version of the monthly CHELSA high resolution climatology product is used to arrive at high resolution hourly climatology fields (the CHELSA dataset is described in (Karger et al. 2017) and the bias correction of it in (Beck et al. 2020a). Like this, high-resolution hourly data from 1981-01-01 through 2013-12-31, i.e. the period for which the CHELSA dataset is available, could be derived. These data are then used for model calibration and validation and for the computation of the reference hydro-climatological situation from 1981 through 2013. More details can be found in Chapter 4. The analysis present here is for the Gunt river catchment. The approach and methods we have developed are universally applicable for other catchments. 3.3.1 CHELSA V1.2.1 Data and Bias Correction The CHELSA V1.2.1 data covers the period 1981-01-01 until 2013-12-31. This period is considered to be the base climate period where 1981-01-01 until 1993-12-31 will be used as the parameter calibration period for the hydrological model. The model validation period is from 1994-01-01 until 2013-12-31. This period will constitute the baseline period in relation to which climatic changes in the mid 21st as well as end of 21st century will be assessed. Mean monthly temperature and total monthly precipitation between 1981-01-01 and 2013-01-01 can be accessed and downloaded for the Central Asia domain from the following online repository3. Mean monthly temperatures are stored in the ./t2m/ folder and precipitation in the ./pr/ folder there. Note that the Central Asia domain is defined as test aoi_CentralAsia_LatLon &lt;- extent(c(65,80.05,35.95,44.05)) # this is a raster::extent() object. For more information, type ?extent into the console. The CHELSA data are downscaled ERA-INTERIM model outputs for temperature and precipitation with a resolution of 30 arc seconds (Karger et al. 2017). Temperature fields are statistically downscaled ERA-INTERIM temperatures whereas for precipitation downscaling, several orographic predictors are taken into account, including for example wind fields, valley exposition, height of the atmospheric boundary layer, etc. Because of its highly resolved climatologies, the CHELSA data has been shown to be particularly useful for studies in regions with complex topography. However, it has also been shown that the original CHELSA precipitation data is underestimating high mountain precipitation. This can be explained by the phenomenon of snow undercatch which explains measured precipitation deficits by sublimation and blowing snow transport at high altitude meteorological stations. An example of this is shown in Figure 3.32 for high elevation gauges in Spain. In a recent intercomparison project carried out in Spain, it has been shown that undercatch poses significant problems in accurately measuring solid precipitation (Buisán et al. 2017) in mountainous regions. Both, ERA-INTERIM and CHELSA themselves assimilate station data in their models and hence are affected by these erroneous measurements. Figure 3.32: Measured snow undercatch values in high-mountain stations in Spain. The values were determined within the World Meteorological Organization Solid Precipitation Intercomparison Experiment (WMO-SPICE). See text for more information and reference. Beck et al. (2020b) has recognized this and released monthly correction factors for the CHELSA data (see Figure 3.33). Figure 3.33: Figure from (Beck et al. 2020b), Supplementary Material. Plate d): Best estimate of global bias correction factors. Plate e): Lower bound estimate of global bias correction factors. Plate f): Upper bound of global bias correction factors. As is clearly visible, bias correction factors in high-mountain Asia, including the parts of Central Asia are significant. The bias corrected CHELSA precipitation (tp) raster data is available via this Dropbox link. Using these temperature as well bias-corrected precipitation data, we can easily compute and display the monthly norm climatology fields over the Central Asia domain4. Here, we just load them and visualize the mean monthly patterns for a consistency check. t2m_meanMonthlyClimate_CHELSA &lt;- raster::brick(&#39;./data/CentralAsiaDomain/CHELSA_V1.2.1/t2m_climatology/t2m_climatology_CA.tif&#39;) names(t2m_meanMonthlyClimate_CHELSA) &lt;- month.abb t2m_meanMonthlyClimate_CHELSA &lt;- t2m_meanMonthlyClimate_CHELSA / 10 - 273.15 # now, the CHELSA data is in deg. C temperature_colors &lt;- brewer.pal(9, &quot;RdYlBu&quot;) %&gt;% colorRampPalette() gplot(t2m_meanMonthlyClimate_CHELSA) + geom_tile(aes(fill = value)) + facet_wrap(~ variable) + scale_fill_gradientn(colours = rev(temperature_colors(5))) + coord_equal() + guides(fill=guide_colorbar(title=&#39;T [deg. C.]&#39;)) Figure 3.34: CHELSA v1.2.1 mean monthly temperature climatology is shown. In a similar way, the bias corrected precipitation climatology can be plotted. Figure 3.35 nicely shows the main precipitation months of the key mountain ranges in the region. The Figure shows that March and April are normally the main precipitation months. # Load file pbcorr_pr_meanMonthlyClimate_CHELSA &lt;- raster::brick(&#39;./data/CentralAsiaDomain/CHELSA_V1.2.1/pr_climatology/pr_climatology_CA.nc&#39;) # Layer names names(pbcorr_pr_meanMonthlyClimate_CHELSA) &lt;- month.abb # Color palette precipitation_colors &lt;- brewer.pal(9, &quot;YlGnBu&quot;) %&gt;% colorRampPalette() # Plot gplot(pbcorr_pr_meanMonthlyClimate_CHELSA) + geom_tile(aes(fill = value)) + facet_wrap(~ variable) + scale_fill_gradientn(colours = precipitation_colors(500)) + coord_equal() + guides(fill=guide_colorbar(title=&#39;P [mm/yr]&#39;)) Figure 3.35: CHELSA v1.2.1 mean monthly precipitation climatology is shown. How can the quality of the CHELSA data in the complex Central Asia domain be assessed? We explore this question the validity of the CHELSA dataset to be able to adequately represent the high-mountain climate in the Pamirs. The key questions here to be answered are does the magnitude of the precipitation yield physically meaningful results, and does the climatology adequately reproduce the seasonal cycle observed one at the stations? Let us address the first question investigating bias corrected precipitation values and comparing these discharge for the Gunt river basin. If \\(P &gt;Q\\) where \\(P\\) is the long-term mean precipitation and \\(Q\\) is the long-term mean discharge, we can confidently say that the bias corrected CHELSA precipitation product is meaningful from a water balance perspective (see also Chapter 2.3 for more information). # Load catchment shp gunt_Shapefile &lt;- st_read(&#39;./data/AmuDarya/Gunt/GeospatialData/Gunt_Basin_poly.shp&#39;,quiet = TRUE) gunt_Shapefile &lt;- gunt_Shapefile %&gt;% subset(fid==2) gunt_Shapefile_LatLon &lt;- st_transform(gunt_Shapefile,crs = st_crs(4326)) areaGunt &lt;- gunt_Shapefile %&gt;% st_area() %&gt;% as.numeric() # Areas of Interest aoi_CentralAsia_LatLon &lt;- extent(c(65,80.05,35.95,44.05)) # in lat/lon aoi_Basin_LatLon &lt;- gunt_Shapefile_LatLon %&gt;% extent() # GUNT aoi_Basin_UTM &lt;- gunt_Shapefile %&gt;% extent() # GUNT, in UTM fLoc &lt;- &#39;./data/AmuDarya/Gunt/ReanalysisData/tp_bcorr_NORM_CHELSA_Gunt.nc&#39; chelsaP_GUNT_corr_raster &lt;- brick(fLoc, varname=&quot;corr_P_annual&quot;) chelsaP_GUNT_corr__spdf &lt;- as(chelsaP_GUNT_corr_raster, &quot;SpatialPixelsDataFrame&quot;) chelsaP_GUNT_corr__df &lt;- as.data.frame(chelsaP_GUNT_corr__spdf) colnames(chelsaP_GUNT_corr__df) &lt;- c(&quot;value&quot;, &quot;x&quot;, &quot;y&quot;) # Plot the raster for inspection and analysis ggplot() + geom_tile(data=chelsaP_GUNT_corr__df, aes(x=x, y=y, fill=value), alpha=0.8)+ geom_sf(data=gunt_Shapefile,color=&quot;black&quot;,fill=NA) + scale_fill_gradientn(colours = precipitation_colors(5)) + xlab(&quot;Longitude&quot;) + ylab(&quot;Latitude&quot;) + guides(fill=guide_colorbar(title=&quot;P Norm [mm]&quot;)) + ggtitle(&quot;Bias Corrected CHELSA v1.2.1 Norm Precipitation, Gunt River Basin&quot;) Figure 3.36: Long-term mean precipitation climatology of the Gunt river basin in the Pamir mountains. The catchment is delineated by the black polygon. The mean long-term precipitation in the catchment is 349 mm/year. # Extract raster values inside basin polygon and convert to equivalent water height rasterRes &lt;- chelsaP_GUNT_corr_raster %&gt;% res() rasterCellArea &lt;- rasterRes[1] * rasterRes[2] # in m^2 basin_P &lt;- raster::extract(chelsaP_GUNT_corr_raster,gunt_Shapefile)[[1]] * rasterCellArea / 1000 basin_P &lt;- basin_P %&gt;% sum() / areaGunt * 1000 # now in mm #print(paste0(&quot;The bias corrected CHELSA v.1.2 norm precipitation in Gunt River Basin is &quot;, basin_P %&gt;% round(0), &#39; mm&#39;)) From the perspective of the water balance, the basin-wide long-term mean precipitation estimate passes the test since P (353 mm) &gt; Q (234 mm) where the latter is the long-term discharge norm at the Khorog gauging station at the outlet of the basin (see also Chapter 2 for more information on Gunt river basin). The water balance components are also discussed in Chapter 2.3. As an aside, the bias corrected precipitation climatology shows an interesting feature of the Gunt river basin (see Figure 3.36). Namely, there is a stark precipitation gradient between the western part of the basin where the bulk of the precipitation is observed and the hyper-arid Pamir plateau region to the east, where annual precipitation is around or below 200 mm. What about the seasonality of the CHELSA product? Can it adequately reproduce the observed precipitation seasonality? If this would not be the case, we would have to reject the validity of the product and explore other high-resolution climatologies such as WorldClim V2 or CHPClim V1 (see (Beck et al. 2020c) for more information on these products). Lets explore again for Gunt river basin. First, we load and prepare all the required station precipitation and geospatial data. Then, we compute the monthly norms of these data for the period 1981-01-01 through 2013-12-31. # Get data (this time, we access the monthly norm data through the specification of the variable name, that we want to load, i.e. varname=&quot;corr_P_monthly&quot;) fLoc &lt;- &#39;./data/AmuDarya/Gunt/ReanalysisData/tp_bcorr_monthly_CHELSA_Gunt.nc&#39; chelsaP_GUNT_monthly_corr_raster_proj &lt;- brick(fLoc, varname=&quot;corr_P_monthly&quot;) # Extract Gunt river basin cells and compute monthly totals chelsa_monthly_norm_P &lt;- extract(chelsaP_GUNT_monthly_corr_raster_proj,gunt_Shapefile)[[1]] * rasterCellArea / 1000 chelsa_monthly_norm_P &lt;- (chelsa_monthly_norm_P %&gt;% colSums() / areaGunt * 1000) %&gt;% unname() # now in mm chelsa_monthly_norm_P &lt;- chelsa_monthly_norm_P %&gt;% as_tibble() %&gt;% rename(CHELSA_norm_P=value) # Load Gunt Station Data record fPath = &#39;./data/AmuDarya/Gunt/StationData/gunt_data_cleaned.Rds&#39; data &lt;- read_rds(fPath) # Prepare the station data precipitation record P_38950 &lt;- data %&gt;% filter(type==&quot;P&quot; &amp; code==38950) %&gt;% dplyr::select(date,data) %&gt;% rename(P_38950=data) P_38953 &lt;- data %&gt;% filter(type==&quot;P&quot; &amp; code==38953) %&gt;% dplyr::select(date,data) %&gt;% rename(P_38953=data) P_38954 &lt;- data %&gt;% filter(type==&quot;P&quot; &amp; code==38954) %&gt;% dplyr::select(date,data) %&gt;% rename(P_38954=data) P_38956 &lt;- data %&gt;% filter(type==&quot;P&quot; &amp; code==38956) %&gt;% dplyr::select(date,data) %&gt;% rename(P_38956=data) P &lt;- full_join(P_38950,P_38953,by=&quot;date&quot;) P &lt;- full_join(P,P_38954,by=&quot;date&quot;) P &lt;- full_join(P,P_38956,by=&quot;date&quot;) # add a month identifier P &lt;- P %&gt;% filter(date&gt;=as.Date(&quot;1981-01-01&quot;) &amp; date&lt;=as.Date(&quot;2013-12-31&quot;)) %&gt;% mutate(mon = month(date)) %&gt;% dplyr::select(-date) P &lt;- P %&gt;% pivot_longer(-mon) %&gt;% group_by(mon) # Now, make a nice plot which compares with the monthly means average over all stations in the catchment. station_monthly_norm_P &lt;- P %&gt;% summarise(Station_norm_P = mean(value,na.rm=TRUE)) %&gt;% dplyr::select(-mon) # Join data norm_P_data &lt;- chelsa_monthly_norm_P %&gt;% add_column(mon=seq(1,12,1),station_monthly_norm_P,.before = 1) # Prepare for plotting norm_P_data_long &lt;- norm_P_data %&gt;% pivot_longer(-mon) # Plot ggplot(norm_P_data_long,aes(x=mon,y=value,color = name)) + geom_line() + xlab(&quot;Month&quot;) + ylab(&quot;mm/month&quot;) Figure 3.37: Monthly precipitation norms of the bias corrected CHELSA v1.2.1 dataset and the mean monthly precipitation averaged over the four meteorological stations in the Gunt river basin. The seasonality of the precipitation is in excellent agreement between the observed data and the bias corrected CHELSA precipitation product. One should not be misled by the offset in absolute terms between the two datasets since since one is data derived from stations at particular locations and the other is average high-resolution gridded data. A better way to plot the comparison of the seasonality of the two products would be to center and standardize the two datasets. This can be achieved the following way. norm_P_data_zscore &lt;- norm_P_data %&gt;% mutate(Station_norm_P_zscore = (Station_norm_P - mean(Station_norm_P))/ sd(Station_norm_P)) %&gt;% mutate(CHELSA_norm_P_zscore = (CHELSA_norm_P - mean(CHELSA_norm_P)) / sd(CHELSA_norm_P)) norm_P_data_zscore_long &lt;- norm_P_data_zscore %&gt;% dplyr::select(-Station_norm_P,-CHELSA_norm_P) %&gt;% pivot_longer(-mon) ggplot(norm_P_data_zscore_long,aes(x=mon,y=value,color = name)) + geom_line() + xlab(&quot;Month&quot;) + ylab(&quot;[-]&quot;) Figure 3.38: Centered and standardized precipitation norms for the comparison of the seasonality of the two products.The bias corrected CHELSA product reproduces the precipitation seasonlity in an excellent manner. Note that the values on the y-axis do not have any units as a result of the standarization. To summarize, with the CHELSA v1.2.1 dataset, we have downloaded and prepared a high spatial resolution climatology for the Central Asia domain. As this product is derived from reanalysis data that mixes station data with climate model output, the precipitation product was bias corrected for snow undercatch that causes the original reanalysis data to greatly underestimate high-elevation precipitation data. As show for Gunt river basin in the Pamirs, the resulting temperature and precipitation climatologies compare in an excellent manner with seasonalities observed at local meteorological stations. For hydrological modeling, however, we need not only high spatial resolution data but also high temporal resolution data, ideally at hourly time-steps, to drive the hydrological model. In the next Section @ref(Data::ERA5), we show how hourly ERA5 reanalysis data fields can be resampled and rescaled so that mean or total monthly values match CHELSA v.1.2.1 at particular raster cells. Like this, we will arrive at a dataset with high temporal and spatial resolution. 3.3.2 ERA5 Download and Data Resampling with PBCORR CHELSA 3.3.2.1 ERA5 Background ERA5 data from 1981-01-01 through 2013-12-31 for the Central Asia domain is available for download under this link. Hourly temperature 2 meters above the surface (t2m) and hourly precipitation (tp) totals can be downloaded there5. More information about ERA5 data can be found on the official website of the European Center of Medium Weather Forecast. With the Lobelia Past Climate Explorer, one can easily get key statistics of any of the ERA5 raster cells globally. Try it! Go to the Central Asia domain, search for your place of interest (i.e. your home, the Gunt river basin, Chirchik river basin, etc.) and click on the point where you would like to see the statistics. See also Figure 3.39 Figure 3.39: Screenshot from the Lovelia ERA5 website with the ERA5 temperature statistics of Khorog selected. ERA5 data can be downloaded from the Copernicus Climate Change Service (C3S) Climate Data Store. We use the ERA5-Land hourly data from 1981 product. Note that if you want to download the data yourself from the Data Store, you need to register there. Figure 3.40: Screenshot from the Copernicus Climate Data Store. One needs to register first if you want to download data yourself from the Climate Data Store (click on Login/register button. The product which we download is highlighted. If you click on it, then the detailed data page comes up. As per the ECMWF description, “ERA5-Land is a reanalysis dataset providing a consistent view of the evolution of land variables over several decades at an enhanced resolution compared to ERA5. ERA5-Land has been produced by replaying the land component of the ECMWF ERA5 climate reanalysis. Reanalysis combines model data with observations from across the world into a globally complete and consistent dataset using the laws of physics. Reanalysis produces data that goes several decades back in time, providing an accurate description of the climate of the past.” For more information, please visit the detailed data description webpage. The variables t2m and tp which you can access via this link are described described in greater detail on the site. For reference, these data specifications are copied in the Table below. ERA5-Land t2m and pr variables descriptions. Name Units Description 2m temperature (t2m) K Temperature of air at 2m above the surface of land, sea or in-land waters. 2m temperature is calculated by interpolating between the lowest model level and the Earth’s surface, taking account of the atmospheric conditions. Temperature measured in kelvin can be converted to degrees Celsius (°C) by subtracting 273.15. Total precipitation (tp) m Accumulated liquid and frozen water, including rain and snow, that falls to the Earth’s surface. It is the sum of large-scale precipitation (that precipitation which is generated by large-scale weather patterns, such as troughs and cold fronts) and convective precipitation (generated by convection which occurs when air at lower levels in the atmosphere is warmer and less dense than the air above, so it rises). Precipitation variables do not include fog, dew or the precipitation that evaporates in the atmosphere before it lands at the surface of the Earth. This variable is accumulated from the beginning of the forecast time to the end of the forecast step. The units of precipitation are depth in meters. It is the depth the water would have if it were spread evenly over the grid box. Care should be taken when comparing model variables with observations, because observations are often local to a particular point in space and time, rather than representing averages over a model grid box and model time step. 3.3.2.2 ERA5-Land Download Note: This Section just demonstrates how you can order data from Copernicus Climate Data Store. It is not required for you to carry this out in order to access the Central Asia 2m temperature and total precipitation data that has been prepared for this course and is available for download here. The manual data download from the Climate Data Store is tedious. We show here how, with an R-script, you can place a data order and then, once the data is prepared, download it from the Data Store. The following code segments show to download daily ERA5 t2m and tp data that is segmented into yearly netCDF-files. Like this, these become manageable for later processing. Note that the two code segments start the scripts on the side of the Climate Data Store data service. Following the submission of jobs and after a wait of a couple of hours, the data can then be downloaded at https://cds.climate.copernicus.eu/cdsapp#!/yourrequests manually and stored in the relevant location. Note that for these scripts to run, you need to give your own credentials that you obtain after login in the Climate Data Store. Under the assumption that you have typed in your credentials (user name, ID and key), 2 meter temperature data can be downloaded in the following way. # Required library library(ecmwfr) # Prepare data download of ERA5 by adding login credentials to the keychain. wf_set_key(user = &#39;&lt;Your user name&gt;&#39;, key = &quot;Your key&quot;, service = &quot;webapi&quot;) downloadList_t2m &lt;- 1981:2013 # The years for which CHELSA v1.2.1 is available are chosen for download. These will be used for the calibration and vaildation of the hydrological model and constitute the reference hydrological period. for (yr in downloadList_t2m){ CentralAsia_ERA5_hourly_request &lt;- list( format = &quot;netcdf&quot;, variable = c(&quot;2m_temperature&quot;), year = as.character(yr), month = c(&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;), day = c(&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot;, &quot;29&quot;, &quot;30&quot;, &quot;31&quot;), time = c(&quot;00:00&quot;, &quot;01:00&quot;, &quot;02:00&quot;, &quot;03:00&quot;, &quot;04:00&quot;, &quot;05:00&quot;, &quot;06:00&quot;, &quot;07:00&quot;, &quot;08:00&quot;, &quot;09:00&quot;, &quot;10:00&quot;, &quot;11:00&quot;, &quot;12:00&quot;, &quot;13:00&quot;, &quot;14:00&quot;, &quot;15:00&quot;, &quot;16:00&quot;, &quot;17:00&quot;, &quot;18:00&quot;, &quot;19:00&quot;, &quot;20:00&quot;, &quot;21:00&quot;, &quot;22:00&quot;, &quot;23:00&quot;), area = c(45, 64, 34, 81), dataset_short_name = &quot;reanalysis-era5-land&quot;, target = paste0(&quot;CentralAsia_ERA5_hourly_&quot;,as.character(yr),&#39;.nc&#39;)) file &lt;- wf_request(user = &quot;Your User ID&quot;, # user ID (for authentication) request = CentralAsia_ERA5_hourly_request, # the request name (can be anything) transfer = FALSE, # put it in the queue and download manually from the website path = &quot;.&quot;, job_name = paste0(&quot;t2m_CentralAsia_ERA5_hourly_&quot;,as.character(yr),&#39;.nc&#39;)) } Similarly, total precipitation is downloaded with the following code. downloadList_tp &lt;- 1981:2013 for (yr in downloadList_tp){ CentralAsia_ERA5_hourly_request &lt;- list( format = &quot;netcdf&quot;, variable = c(&quot;total_precipitation&quot;), year = as.character(yr), month = c(&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;), day = c(&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot;, &quot;29&quot;, &quot;30&quot;, &quot;31&quot;), time = c(&quot;00:00&quot;, &quot;01:00&quot;, &quot;02:00&quot;, &quot;03:00&quot;, &quot;04:00&quot;, &quot;05:00&quot;, &quot;06:00&quot;, &quot;07:00&quot;, &quot;08:00&quot;, &quot;09:00&quot;, &quot;10:00&quot;, &quot;11:00&quot;, &quot;12:00&quot;, &quot;13:00&quot;, &quot;14:00&quot;, &quot;15:00&quot;, &quot;16:00&quot;, &quot;17:00&quot;, &quot;18:00&quot;, &quot;19:00&quot;, &quot;20:00&quot;, &quot;21:00&quot;, &quot;22:00&quot;, &quot;23:00&quot;), area = c(45, 64, 34, 81), dataset_short_name = &quot;reanalysis-era5-land&quot;, target = paste0(&quot;CentralAsia_ERA5_hourly_&quot;,as.character(yr),&#39;.nc&#39;)) file &lt;- wf_request(user = &quot;11732&quot;, # user ID (for authentication) request = CentralAsia_ERA5_hourly_request, # the request transfer = FALSE, # put it in the queue and download manually from the website path = &quot;.&quot;, job_name = paste0(&quot;tp_CentralAsia_ERA5_hourly_&quot;,as.character(yr),&#39;.nc&#39;)) } 3.3.2.3 Rescaling ERA5 to monthly CHELSA values ERA5 original data can easily be rescaled (bias corrected) to CHELSA data values for any river basin in the Central Asia domain using the convenience function riversCentralAsia::biasCorrect_ERA5_CHELSA(). Type ?biasCorrect_ERA5_CHELSA to get more information about the function and its arguments. The code block below shows how to rescale (bias correct) total precipitation. It assumes that the ERA5 directory contains two subfolders ERA5/tp/ and ERA5/t2m where the corresponding data are stored. # Specify biasCorrect_ERA5_CHELSA() function arguments basinName &lt;- &#39;Gunt&#39; dataType_ERA5 &lt;- &#39;tp&#39; # note that ERA5 tp units are in m! ## Directories of relevant climate files - function arguments dir_ERA5_hourly &lt;- &#39;../HydrologicalModeling_CentralAsia_Data/CentralAsiaDomain/ERA5/&#39; dir_CHELSA &lt;- &#39;../HydrologicalModeling_CentralAsia_Data/CentralAsiaDomain/CHELSA_V1.2.1/&#39; # start and end times - function arguments startY &lt;- 1981 endY &lt;- 2013 biasCorrect_ERA5_CHELSA(dir_ERA5_hourly,dataType_ERA5,dir_CHELSA,startY,endY,basinName,gunt_Shapefile_LatLon) By simply switching the data type (effectively, it just looks for the files in the corresponding directory), temperature can be rescaled to the CHELSA field values for each month. # Specify biasCorrect_ERA5_CHELSA() function arguments basinName &lt;- &#39;Gunt&#39; dataType_ERA5 &lt;- &#39;t2m&#39; # note that ERA5 tp units are in m! ## Directories of relevant climate files - function arguments dir_ERA5_hourly &lt;- &#39;../HydrologicalModeling_CentralAsia_Data/CentralAsiaDomain/ERA5/&#39; dir_CHELSA &lt;- &#39;../HydrologicalModeling_CentralAsia_Data/CentralAsiaDomain/CHELSA_V1.2.1/&#39; # start and end times - function arguments startY &lt;- 1981 endY &lt;- 2013 biasCorrect_ERA5_CHELSA(dir_ERA5_hourly,dataType_ERA5,dir_CHELSA,startY,endY,basinName,gunt_Shapefile_LatLon) In order to understand if the rescaling of the ERA5 data lead to meaningful results, we can compare monthly precipitation totals from the final ERA5 data to monthly station values, average over the four meteorological stations that we have. basinName &lt;- &#39;Gunt&#39; dataType_ERA5 &lt;- &#39;tp&#39; # note that ERA5 tp units are in m! ## Directories of relevant climate files - function arguments dir_ERA5 &lt;- &#39;../HydrologicalModeling_CentralAsia_Data/CentralAsiaDomain/ERA5/&#39; # Note: ERA5 data in m # basin basin_shp_latlon &lt;- gunt_Shapefile_LatLon # start and end times - function arguments startY &lt;- 1981 endY &lt;- 2013 # Date sequence sTime &lt;- paste0(startY,&#39;-01-01 01:00:00&#39;) eTime &lt;- paste0(endY,&#39;-12-31 23:00:00&#39;) dateSeq_ERA &lt;- seq(as.POSIXct(sTime), as.POSIXct(eTime), by=&quot;hour&quot;) dateSeq_ERA &lt;- tibble(date=dateSeq_ERA, data=NA) dateSeq_ERA &lt;- dateSeq_ERA %&gt;% mutate(month = month(date)) %&gt;% mutate(year = year(date)) # Create Basin subdirectory (if not already existing) to store dedicated annual files there mainDir &lt;- paste0(dir_ERA5,dataType_ERA5,&#39;/&#39;,basinName,&#39;/&#39;) # Start data fetching for (yr in startY:endY){ # progress indicator print(paste0(&#39;PROCESSING YEAR &#39;,yr)) # file handling file2Process_ERA &lt;- paste0(dataType_ERA5,&#39;_ERA5_hourly_&#39;,basinName,&#39;_bcorr_&#39;,yr,&#39;.nc&#39;) era_data&lt;- brick(paste0(mainDir,file2Process_ERA)) # extract the data over the basin dateSeq_ERA$data[dateSeq_ERA$year==yr] &lt;- raster::extract(era_data,basin_shp_latlon,fun=mean) } dateSeq_ERA_mon &lt;- dateSeq_ERA %&gt;% dplyr::select(date,data) if (dataType_ERA5==&#39;t2m&#39;){ era5_data_mon &lt;- dateSeq_ERA_mon %&gt;% timetk::summarize_by_time(.date_var = date,.by = &#39;month&#39;,era5_data_mon = mean(data),.type = &#39;ceiling&#39;) station_data_mon &lt;- data %&gt;% filter(type==&#39;mean(T)&#39; &amp; resolution==&#39;mon&#39;) %&gt;% dplyr::select(date,data,code) %&gt;% filter(date&gt;=(dateSeq_ERA_mon$date %&gt;% first())) %&gt;% filter(date&lt;=(dateSeq_ERA_mon$date %&gt;% last())) %&gt;% pivot_wider(names_from = &#39;code&#39;,values_from = data) %&gt;% mutate(station_data_mon = rowMeans(dplyr::select(.,-date),na.rm=TRUE)) %&gt;% dplyr::select(date,station_data_mon) } else { era5_data_mon &lt;- dateSeq_ERA_mon %&gt;% timetk::summarize_by_time(.date_var = date,.by = &#39;month&#39;,era5_data_mon = sum(data),.type = &#39;ceiling&#39;) era5_data_mon$era5_data_mon &lt;- era5_data_mon$era5_data_mon * 1000 # in mm now station_data_mon &lt;- data %&gt;% filter(type==&#39;P&#39; &amp; resolution==&#39;mon&#39;) %&gt;% dplyr::select(date,data,code) %&gt;% filter(date&gt;=(dateSeq_ERA_mon$date %&gt;% first())) %&gt;% filter(date&lt;=(dateSeq_ERA_mon$date %&gt;% last())) %&gt;% pivot_wider(names_from = &#39;code&#39;,values_from = data) %&gt;% mutate(station_data_mon = rowMeans(dplyr::select(.,-date),na.rm=TRUE)) %&gt;% dplyr::select(date,station_data_mon) } era5_data_mon$date &lt;- (era5_data_mon$date - 3600) %&gt;% as.Date() data_validation &lt;- full_join(era5_data_mon,station_data_mon,by=&#39;date&#39;) data_validation %&gt;% pivot_longer(-date) %&gt;% plot_time_series(.date_var = date,.value = value,.smooth = FALSE, .color_var = name,.title = &quot;&quot;,.x_lab = &quot;Year&quot;,.y_lab = &quot;mm/month&quot;,.interactive = FALSE) Figure 3.41: Comparison of mean monthly precipitation values of the Gunt meteorlogical Stations with the rescaled ERA5 data in the basin. The timeseries compare favorably, both in terms of seasonality and interannual variability. 3.3.2.4 Downscaling ERA5 to Basin Elevation Bands and Data Export to RS MINERVE Database file The next and last step for the preparation of the input data required for hydrological modeling involves the downscaling of the prepared hourly ERA5 data to the individual subbasins and elevation bands inside a catchment. The process of generating the input files is shown by using data from the Gunt river basin. The Gunt river basin outline is shown in Figure 3.42. We want to downscale the prepared hourly ERA5 climate fields over the domain of the Gunt river basin to the individual subbasins and the elevation bands of these subbasins (see Figures 3.42 to ?? below). In other words, we want to generate hourly climate timeseries of mean temperature and precipitation levels for each subbasin and all of the elevation bands in each subbasin. The hydrological processes of each of these subbasin elevation bands will then be modeled with a separate model. All these individual hydrological models will be interconnected according to the existing flow topology in the basin. Like this, we arrive at a lumped (lumped over the subbasin-specific elevation bands), semi-distributed (distributed between the subbasins and elevation bands) hydrological model of the entire catchment. Figure 3.42: The outline of the Gunt river catchment is shown with the key river sections of all tributariies from the corresponding subbasins. Figure 3.43: Gunt river catchment with the individual subbasins is shown. These subbasins are further divided into elevation band zones and the mean climate finally extracted over these subbasin-specfic elevation bands (see Figure (ref?)(fig:guntSubasinsElevationBands)). Figure 3.44: The Gunt river catchment elevation bands are shown in red color. The entire catchment was divided into 4 altitude zones with an interval spacing of 1’000 meters. In real world climate impact studies, elevation bands are normally generated with an interval spacing of 200 - 500 meters. Figure 3.45: The naming concention of the subbasins is shown. For each subbasin, the bands are identified with a suffix .._b1 for elevation band 1, .._b2 for elevation band 2 and so on. Figure 3.46: Subbasin elevation band attribute table. In total there are 14 elevation bands and for each elevation band, a climate time series is created with the function riversCentralAsia::generate_ERA5_Subbasins_CSV(). The Z field is important and specifies the average elevation of the corresponding elevation band for each subbasin. The code block assumes that the previously described steps have been carried and that the corresponding files are stored in the correct relative path locations. First, ERA5 precipitation is downscaled with generate_ERA5_Subbasin_CSV(...) with dataType='tp' set. Second, dataType='t2m' for the downscaling of the 2 meter above surface ERA5 temperature. In a third step, we add the discharge data to the resulting data frame in the last column. Finally, the observed discharge data is added. Note here that we add the gap filled time series of the observational record. The process of gap filling discharge data is described in Section 3.1.2 above. # Housekeeping dir_ERA5 &lt;- &#39;../HydrologicalModeling_CentralAsia_Data/CentralAsiaDomain/ERA5/&#39; catchmentName &lt;- &#39;Gunt&#39; elBands_shp &lt;- st_read(&#39;../HydrologicalModeling_CentralAsia_Data/AmuDarya/Gunt/GeospatialData/Gunt_ElevationBands_Subbasins_RSMinerve.shp&#39;) startY &lt;- 1981 endY &lt;- 2013 # 1. Downscaling precipitation dataType &lt;- &#39;tp&#39; # Precipitation gunt_db_tp &lt;- generate_ERA5_Subbasin_CSV(dir_ERA5_hourly,catchmentName,dataType,elBands_shp,startY,endY) # 2. Downscaling temperature dataType &lt;- &#39;t2m&#39; # Temperature gunt_db_t2m &lt;- generate_ERA5_Subbasin_CSV(dir_ERA5_hourly,catchmentName,dataType,elBands_shp,startY,endY) # 3. Joining the two data frames. gunt_db &lt;- gunt_db_t2m %&gt;% add_column(gunt_db_tp %&gt;% dplyr::select(-Station),.name_repair = &#39;unique&#39;) # 4. Adding the observed discharge data in the required format to the data frame gunt_db_Q &lt;- q_17050_mon_filled %&gt;% dplyr::select(date,data) gunt_db_Q$date &lt;- gunt_db_Q$date %&gt;% as.POSIXct() + 22 * 60 * 60 # just adding time so that we are indeed at the end of the month datesChar_Q &lt;- posixct2rsminerveChar(gunt_db_Q$date) %&gt;% rename(Station=value) datesChar_Q &lt;- datesChar_Q %&gt;% add_column(Q_17050 = (gunt_db_Q$data %&gt;% as.character)) gunt_db_Q &lt;- full_join(gunt_db,datesChar_Q,by=&#39;Station&#39;) # this works well # now finish off by giving the required attributes in the table for the discharge station gunt_db_Q$Q_17050[1] = &#39;Q_17050&#39; gunt_db_Q$Q_17050[2] = meteoStations$utm.x[2] gunt_db_Q$Q_17050[3] = meteoStations$utm.y[2] gunt_db_Q$Q_17050[4] = meteoStations$masl[2] gunt_db_Q$Q_17050[5] = &#39;Q&#39; gunt_db_Q$Q_17050[6] = &#39;Flow&#39; gunt_db_Q$Q_17050[7] = &#39;m3/s&#39; gunt_db_Q$Q_17050[8] = &#39;Constant before&#39; The resulting data frame can be stored with write.table(..,..,sep=',',row.names = FALSE,col.names=FALSE,quote=FALSE) as a csv-file and the read into RS MINERVE later. A screenshot of the csv-file is below in Figure 3.47. Elevation band-specific temperature (T) and precipitation (P) data are stored in columns. The last column contains the discharge data Q. If more than one observation station are available, more discharge columns would correspondingly need to be added. In row 1 - 8, elevation band specific information is stored. More specifically, the following information is contained: Row 1: Name of elevation band and discharge station(s) Row 2: Longitude of centroid of elevation band and location of gauging station(s) (in meters, UTM) Row 3: Latitude of centroid of elevation band and location of gauging station(s) (in meters, UTM) Row 4: Mean elevation across elevation band and elevation of gauging station(s) Row 5: Observation type indicator (T: temperature, P: precipitation and Q: discharge) Row 6: Category Row 7: Measurement units Row 8: Interpolation method for downsampling course resolution time series6 Figure 3.47: Screenshot of the resulting large csv file that can be read into RS MINERVE. From rows 9 onward, the actual data are stored where a time stamp in the first column corresponds to the corresponding observation data and time. Please note that the total size of this repository is 2 GB, approximately. Prior to downloading these data, you should ensure that you have enough storage space on your local machine. Furthermore, it is advised that you create the directory structure in the following way: FILES/PROJECT -Code —yourRProject.Rproj —code1.R —… -HydrologicalModeling_CentralAsia_Data — where FILES/PROJECT is the folder where you keep your documents on your computer and project denotes the folder name of your project, Code is the folder where all your code lives and HydrologicalModeling_CentralAsia_Data is the folder where you store all the accompanying data that can downloaded.↩︎ The code for the computation of the CHELSA long-term monthly mean temperature and precipitation climatologies is provided in the Appendix C in the corresponding Sect.↩︎ Please note that one raster brick that encompasses the data for one year is approx 333 MB to download!↩︎ This is for example used to downsample monthly discharge as provided by the hydrometeorological agency to hourly discharge (we use hourly simulation time steps in the hydrological model).↩︎ "],["data-on-climate-projections.html", "3.4 Data on Climate Projections", " 3.4 Data on Climate Projections In order to look into the future with a hydrological model for exploring climate scenarios, it needs to be fed with those scenarios. The production of these scenarios in a way resembles the steps described for the reanalysis data but also differs in some marked way. Let us outline them first before diving into the details. First, the period of interest for the investigation of climate impacts needs to be defined. Future climate scenarios need then need to be identified that cover the area and period of interest. The future climate scenarios are outputs from global climate models (GCMs). These GCMs normally generate monthly data as a function of representative concentration pathways (called RCPs). They describe possible futures as a function of different atmospheric CO2-concentration scenarios. We focus the discussion here on the RCP 4.5 and RCP 8.5 concentration scenarios. According to the IPCC, RCP 4.5 is an intermediate scenario where CO2 emissions peak around 2040, then decline. Compared to this RCP 8.5 is generally considered to be a worst case climate change scenario. Very detailed information regarding these scenarios, their underlying assumptions and assumptions can be found on the dedicated website served by the Intergovernmental Panel for Climate Change (IPCC). See the link here. Figure 3.48: The development of greenhouse gas concentrations during the 21st century as a function of the corresponding scenario. We focus here on RCP4.5 and RCP8.5. Source: (Vuuren et al. 2011) 3.4.1 High Resolution Monthly Climate Time Series for 2006 - 2100 The recently released high-resolution climate scenario datasets described by (Karger et al. 2020) are utilized here to study climate impacts in river basins in the Central Asia region. The authors of the aforementioned paper present GCMs output for monthly precipitation, mean minimum as well as maximum monthly temperatures that has been downscaled using the CHELSA algorithm. The data can be found here https://www.envidat.ch/#/metadata/chelsa_cmip5_ts. We download data from 3 out of the 4 available downscaled GCM runs for further analysis and processing. These are outputs from the Coupled Model Intercomparison Project phase 5 (CMIP5) and are gridded monthly time series from the years 2006 through 2100 with a spatial resolution of 0.049 degrees (see again (Karger et al. 2020) for all the details). The three models from which data were taken are: CMCC-CM run by the Centro Euro-Mediterraneo per I Cambiamenti Climatici (CMCC); MIROC5 run by the University of Tokyo; and ACCESS1-3 run by the Commonwealth Scientific and Industrial Research Organization (CSIRO) and Bureau of Meteorology (BOM), Australia (Karger et al. 2020). First, the data is downloaded and stored locally for RCP 4.5 and RCP 8.5. Then, as in the case of the original CHELSA data, the monthly gridded precipitation timeseries are bias corrected using the monthly correction factors as report by (Beck et al. 2020d) and finally, mean monthly temperature fields are generated from the minimum and maximum monthly temperatures. The resulting data available for the Central Asia domain are available for download via this link7. As in the case of the ERA5 data, these GCM data need to be made available for all the elevation bands. By providing a proper shapefile that contains sub-basin specific elevation bands of a catchment, the function riversCentralAsia::downscale_ClimPred_monthly_BasinElBands() can be used to compute this. This function processes the climate projection raster bricks with precipitation_flux and air_temperature (tasmin, tasmean and tasmax) and computes elevation band statistics. The next code block provides sample code on how to use riversCentralAsia::downscale_ClimPred_monthly_BasinElBands(). If you want to try this locally on your computer, it is required that you download the entire high resolution climate scenarios for the Central Asia on your local machine. The data are available under this link. The whole process is shown here using a shapefile of the Gunt river basin that explicitly includes Lake Yashikul in the upstream of the basin. In lieu, your own catchment files can easily be loaded and provided. # Data climScen_Path &lt;- &#39;../HydrologicalModeling_CentralAsia_Data/CentralAsiaDomain/PROJECTIONS/&#39; # This Path would need to be adjusted for in case the directory with the climate projections is stored elsewhere. rcp &lt;- c(&#39;rcp45&#39;,&#39;rcp85&#39;) cModelList &lt;- c(&#39;ACCESS1-3&#39;,&#39;CMCC-CM&#39;,&#39;MIROC5&#39;) # Catchment Shapefile elBands_shp &lt;- st_read(&#39;./data/AmuDarya/GuntYashikul/GeospatialData/subbasins_Z.shp&#39;) # Ensure Projection is latlon elBands_shp_latlon &lt;- sf::st_transform(elBands_shp,crs = sf::st_crs(4326)) # Unused catchments in RSMinerve? Preprocess Shapefile: This is specific for the Gunt-Yashikul model and can be removed if not required or change accordingly. elBands_shp_latlon &lt;- elBands_shp_latlon %&gt;% dplyr::slice(-1:-3) # Fancy trick to generate an empty dataframe with column names from a vector of characters. namesElBands &lt;- elBands_shp_latlon$name dataElBands_df &lt;- namesElBands %&gt;% purrr::map_dfc(setNames, object = base::list(base::logical())) # Start and end years of climate projections startY &lt;- 2006 endY &lt;- 2100 # Search pattern for file list fileListSearchPattern &lt;- &quot;2006-2100&quot; # Generate downscaled climate scenario files and store files in corresponding directory # RCP45 pathN &lt;- paste0(climScen_Path,&#39;rcp45&#39;,&#39;/&#39;,&#39;ACCESS1-3&#39;,&#39;/&#39;) downscaled_ClimPred_rcp45_ACCESS1_3 &lt;-downscale_ClimPred_monthly_BasinElBands(pathN,fileListSearchPattern, startY,endY,elBands_shp_latlon) pathN &lt;- paste0(climScen_Path,&#39;rcp45&#39;,&#39;/&#39;,&#39;CMCC-CM&#39;,&#39;/&#39;) downscaled_ClimPred_rcp45_CMCC_CM &lt;- downscale_ClimPred_monthly_BasinElBands(pathN,fileListSearchPattern, startY,endY,elBands_shp_latlon) pathN &lt;- paste0(climScen_Path,&#39;rcp45&#39;,&#39;/&#39;,&#39;MIROC5&#39;,&#39;/&#39;) downscaled_ClimPred_rcp45_MIROC5 &lt;- downscale_ClimPred_monthly_BasinElBands(pathN,fileListSearchPattern, startY,endY,elBands_shp_latlon) # RCP85 pathN &lt;- paste0(climScen_Path,&#39;rcp85&#39;,&#39;/&#39;,&#39;ACCESS1-3&#39;,&#39;/&#39;) downscaled_ClimPred_rcp85_ACCESS1_3 &lt;-downscale_ClimPred_monthly_BasinElBands(pathN,fileListSearchPattern, startY,endY,elBands_shp_latlon) pathN &lt;- paste0(climScen_Path,&#39;rcp85&#39;,&#39;/&#39;,&#39;CMCC-CM&#39;,&#39;/&#39;) downscaled_ClimPred_rcp85_CMCC_CM &lt;- downscale_ClimPred_monthly_BasinElBands(pathN,fileListSearchPattern, startY,endY,elBands_shp_latlon) pathN &lt;- paste0(climScen_Path,&#39;rcp85&#39;,&#39;/&#39;,&#39;MIROC5&#39;,&#39;/&#39;) downscaled_ClimPred_rcp85_MIROC5 &lt;- downscale_ClimPred_monthly_BasinElBands(pathN,fileListSearchPattern, startY,endY,elBands_shp_latlon) # # Store files (if required, in the corresponding catchment-specific folder) # basin_climScen_Path &lt;- &#39;./data/AmuDarya/GuntYashikul/ClimateProjections/&#39; # # climScen_fileList &lt;- c(&#39;downscaled_ClimPred_rcp45_ACCESS1_3&#39;, &#39;downscaled_ClimPred_rcp45_CMCC_CM&#39;, # &#39;downscaled_ClimPred_rcp45_MIROC5&#39;,&#39;downscaled_ClimPred_rcp85_ACCESS1_3&#39;, # &#39;downscaled_ClimPred_rcp85_CMCC_CM&#39;,&#39;downscaled_ClimPred_rcp85_MIROC5&#39;) # # save(climScen_fileList,list = climScen_fileList,file = paste0(basin_climScen_Path,&#39;climScen_monthly&#39;,&#39;.rda&#39;)) As discussed, these GCM data are high resolution monthly future climate fields which we downscaled on the corresponding catchment shapefile with its subbasins and elevation bands. All good. But how do we arrive at climate fields that have a high hourly temporal resolution at the same time so that we can drive the RS MINERVE hydrological model with the required input data? The solution is shown in the next section. 3.4.2 Using a Weather Generator to Simulate Daily Future Climate 3.4.2.1 Background and Input File Generation Stochastic weather generators are probabilistic models that are used to simulate weather data at a specific site or region by analyzing historical weather data and then generating a time-series of weather variables with statistical properties identical to the historical data (Birt et al. 2010). We demonstrate the use of RMAWGEN, a stochastic weather generator available for the R environment. Further information on RMAWGEN can be found here https://github.com/ecor/RMAWGEN and under the links provided via this GitHub link. While the weather generator is relatively poorly documented, a useful albeit very technical presentation of the tool is available here. RMAWGEN allows for the generation of daily temperature and precipitation scenarios that are conditioned on monthly totals as given by the GCM model outputs. This is the key idea. In order to arrive at the final hourly data, we then simply distribute the daily data evenly over the hours of that particular day. Using again an example of the Gunt river basin, the following code block shows how to use the function prepare_RMAWGEN_input_data() for the preparation of the relevant RMAWGEN input data files. # Load and process RS MINERVE csv database file filePath &lt;- &#39;./data/AmuDarya/Gunt/RSMinerve/&#39; fileName &lt;- &#39;Gunt_1981_2013.csv&#39; era5_gunt &lt;- read.table(paste0(filePath,fileName),sep=&#39;,&#39;) %&gt;% as_tibble() rmawgen_input_files &lt;- prepare_RMAWGEN_input_data(era5_gunt) rmawgen_input_files %&gt;% list2env(.,envir = .GlobalEnv) # Send list variables to global environment (it is a type of unlist). The function returns a list rmawgen_input_files with all key information that can be unlisted using rmawgen_input_files %&gt;% list2env(.,envir = .GlobalEnv). This includes: STATION_NAMES: Character vector of station names (effectively, these are just the subbasin names extracted from the RS MINERVE input file). ELEVATION: Mean elevation of the stations STATION_LATLON: Matrix with station names, latitude and longitude LOCATION: Same as the station name, used above. PRECIPITATION: Tibble containing daily precipitation for each station TEMPERATURE_MIN: Minimum daily temperature (calculated from the ERA5 hourly data stored in the RS MINERVE csv file) TEMPERATURE_MAX: Maximum daily temperature (ditto) A weather generator is a type of model that uses input data to simulate output variables. Exactly like for example a hydrological runoff model, it depends on input parameters and different input parameter configuration lead to different model performance / outcomes. Hence, before generating future climate scenarios for which we do not have a validation set available to assess the performance of different parameter configurations of the weather generator, we assess model performance by using ERA5 data for calibration and model validation. The simple question to be answered here is whether or not the model is able to reproduce the statistical characteristics of the ERA5 dataset in the region of interest. If yes, we can safely assume that the weather generator can in a more or less realistic manner generate stochastic future climate scenarios that are conditioned on monthly GCM temperature and precipitation fields. A typical parameter set of RMAWGEN for testing different models can be specified in the following way. Housekeeping set.seed(123456) # Random generator seed is set to make results reproducible. # Monthly climate is calculated if it is set to NULL. PREC_CLIMATE &lt;- NULL # Calibration Period year_min &lt;- 1981 year_max &lt;- 2013 origin &lt;- origin &lt;- &quot;1981-1-1&quot; # This is the starting date for which we have data available. # n GPCA iterations for variable and VAR residuals n_GPCA_iter &lt;- 5 n_GPCA_iteration_residuals &lt;- 5 # Autoregression orders (p) and exogenous vars p_test &lt;- 1 p_prec &lt;- 3 exogen &lt;- NULL exogen_sim &lt;- exogen # number of weather realizations nscenario &lt;- 1 # Simulation period year_min_sim &lt;- year_min # we are not yet simulating future climate but use the available data for model assessment, hence year_min_sim = year_min year_max_sim &lt;- year_max # we are not yet simulating future climate but use the available data for model assessment, hence year_max_sim = year_max # Minimum Precipitation value below which no precip is considered valmin &lt;- 1.0 3.4.2.2 Model Calibration and Validation Different parameter combinations can now be tested and the model performance assessed as a function of these configurations. Detailed information about the core functions of RMAWGEN can be obtained by consulting their help, i.e. by for example typing ?ComprehensivePrecipitationGenerator. # P03GPCA_prec generationP03GPCA_prec &lt;- ComprehensivePrecipitationGenerator( station = STATION_NAMES, prec_all = PRECIPITATION, year_min = year_min, year_max = year_max, p = p_prec, n_GPCA_iteration = n_GPCA_iter, n_GPCA_iteration_residuals = n_GPCA_iteration_residuals, exogen = exogen, exogen_sim = exogen_sim, sample = &quot;monthly&quot;, mean_climate_prec = PREC_CLIMATE, no_spline = FALSE, year_max_sim = year_max_sim, year_min_sim = year_min_sim ) model1 &lt;- generationP03GPCA_prec # P01GPCA generationP01GPCA_prec &lt;- ComprehensivePrecipitationGenerator( station = STATION_NAMES, prec_all = PRECIPITATION, year_min = year_min, year_max = year_max, p = p_test, n_GPCA_iteration = n_GPCA_iter, n_GPCA_iteration_residuals = n_GPCA_iteration_residuals, exogen = exogen, exogen_sim = exogen_sim, sample = &quot;monthly&quot;, mean_climate_prec = PREC_CLIMATE, no_spline = FALSE, year_max_sim = year_max_sim, year_min_sim = year_min_sim ) model2 &lt;- generationP01GPCA_prec # P03 generationP03_prec &lt;- ComprehensivePrecipitationGenerator( station = STATION_NAMES, prec_all = PRECIPITATION, year_min = year_min, year_max = year_max, p = p_prec, n_GPCA_iteration = 0, n_GPCA_iteration_residuals = 0, exogen = exogen, exogen_sim = exogen_sim, sample = &quot;monthly&quot;, mean_climate_prec = PREC_CLIMATE, no_spline = FALSE, year_max_sim = year_max_sim, year_min_sim = year_min_sim ) model3 &lt;- generationP03_prec # P01 generationP01_prec &lt;- ComprehensivePrecipitationGenerator( station = STATION_NAMES, prec_all = PRECIPITATION, year_min = year_min, year_max = year_max, p = p_test, n_GPCA_iteration = 0, n_GPCA_iteration_residuals = 0, exogen = exogen, exogen_sim = exogen_sim, sample = &quot;monthly&quot;, mean_climate_prec = PREC_CLIMATE, no_spline = FALSE, year_max_sim = year_max_sim, year_min_sim = year_min_sim ) model4 &lt;- generationP01_prec The performance of the 4 models can be assessed with statistical tests and graphically, with qq-plots and through the comparison of simulated versus observed monthly precipitation totals. Results are shown in the Figures below. Figure 3.49: The comparison of the 4 stochastic weather generator models in terms of their abilities to reproduce monthly precipitation totals is shown for one station (elevation band) in the Gunt river basin. Results indicate that precipitation totals from the models 1 and 2 are overestimated. In comparison, models 3 and 4 are more balanced and not biased. Figure 3.50: Q-Plots of the four model results. If data plots along the diagonal line, it is an indication that the probability distribution of the simluated precipptation (y-axis) is the same as the probability distribution of the observed ERA5 precipitation (x-axis). QQ-plots of models 1 and 2 show a heavy bias whereas model 4 shows an overal satisfactory fit and thus performance. All four models pass the multivariate Portmanteau and Breusch-Godfrey (Lagrange Multiplier) tests, which verify the absence of time-autocorrelation of the VAR(p) residuals in the modeled precipitation time series (seriality test). Furthermore, all models pass the Jarque-Bera multivariate skewness and kurtosis test, which validate the multivariate Gaussian probability distribution of the VAR(p) residuals (normality test). See (Bernhard 2008) for more information. Figure 3.49 and Figure 3.50 show that the Model 4 provides an overall well-balanced performance. We will thus us this models to generate the future climate fields. Temperature is not independent of precipitation and vice versa. The two climate state variables and their changes are interlinked. Simply put, in the warm season over continents, higher temperatures accompany lower precipitation amounts and vice versa. Hence, over land, strong negative correlations dominate, as dry conditions favor more sunshine and less evaporative cooling, while wet summers are cool (see e.g. IPCC Fourth Assessment Report: Climate Change 2007, Working Group I, The Physical Science Basis, Section 3.3.5, available here). This needs to be taken into account when simulating weather. To account for this, we will use the model4 configuration to produce simulated weather over the calibration and validation period. First, we will generate multi-site synthetic future temperature time series. Second, we use these temperatures as exogenous predictors in the precipitation generation step. If the results are satisfactory, we proceed with this stochastic weather model to produce future simulated weather runs that are conditioned on GCM output for the mid-21st and end of 21st century. Using the model4 parameters from above, the following code block demonstrates how to conduct these coupled temperature and precipitation runs. Since RMAWGEN is a multi-site weather generator, the algorithm exploits the spatial interdependence of the time series for the simulation of synthetic weather. set.seed(123456) year_max &lt;- 2013 year_min &lt;- 1981 origin &lt;- &quot;1981-1-1&quot; n_GPCA_iter &lt;- 0 n_GPCA_iteration_residuals &lt;- 0 n_GPCA_iter_prec &lt;- 0 n_GPCA_iteration_residuals_prec &lt;- 0 p &lt;- 1 station &lt;- STATION_NAMES # generation of temperature max and min generation00_temp &lt;- ComprehensiveTemperatureGenerator(station = station, Tx_all = TEMPERATURE_MAX, Tn_all = TEMPERATURE_MIN, year_min = year_min, year_max = year_max, p = p, n_GPCA_iteration = n_GPCA_iter, n_GPCA_iteration_residuals = n_GPCA_iteration_residuals, sample = &quot;monthly&quot;) # Use of measured and observed temperature as exogenous variables exogen_sim &lt;- cbind(generation00_temp$output$Tx_gen,generation00_temp$output$Tn_gen) names(exogen_sim) &lt;- cbind(paste(names(generation00_temp$output$Tx_gen),&quot;_Tx&quot;,sep=&quot;&quot;), paste(names(generation00_temp$output$Tn_gen),&quot;_Tn&quot;,sep=&quot;&quot;)) exogen &lt;- cbind(generation00_temp$input$Tx_mes,generation00_temp$input$Tn_mes) names(exogen) &lt;- cbind(paste(names(generation00_temp$input$Tx_mes),&quot;_Tx&quot;,sep=&quot;&quot;), paste(names(generation00_temp$input$Tn_mes),&quot;_Tn&quot;,sep=&quot;&quot;)) # Precipitation Generator (temperature enters as exogenous variable) valmin &lt;- 1.0 # Threshold value below which a no precipitation event is recorded [in mm/day]. generation00_prec &lt;- ComprehensivePrecipitationGenerator(station = station, prec_all = PRECIPITATION, year_min = year_min, year_max = year_max, exogen = exogen, exogen_sim = exogen_sim, p = p, n_GPCA_iteration = n_GPCA_iter_prec, n_GPCA_iteration_residuals = n_GPCA_iteration_residuals_prec, sample = &quot;monthly&quot;, valmin = valmin, extremes = TRUE) # Post-processing results prec_mes &lt;- generation00_prec$prec_mes prec_gen &lt;- generation00_prec$prec_gen vprec_mes &lt;- prec_mes[,1] vprec_gen &lt;- prec_gen[,1] qqplot(vprec_mes[!is.na(vprec_mes) &amp; vprec_mes&gt;valmin],vprec_gen[vprec_gen&gt;valmin &amp; !is.na(vprec_gen)],xlab=&quot;measured&quot;,ylab=&quot;generated&quot;,main=paste(&quot;Q-Qplot precipitation at &quot;,names(vprec_gen),sep=&quot;&quot;)) qqplot(vprec_mes,vprec_gen,xlab=&quot;measured&quot;,ylab=&quot;generated&quot;,main=paste(&quot;Q-Qplot precipitation at &quot;,names(vprec_gen),sep=&quot;&quot;)) mes &lt;- length(vprec_mes[!is.na(vprec_mes) &amp; vprec_mes&gt;0])/length(vprec_mes[!is.na(vprec_mes)]) gen &lt;- length(vprec_mes[!is.na(vprec_gen) &amp; vprec_gen&gt;0])/length(vprec_gen[!is.na(vprec_gen)]) data_gen &lt;- extractmonths(data=generation00_prec$prec_gen,when=c(&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;),origin=&quot;1961-1-1&quot;) data_mes &lt;- extractmonths(data=generation00_prec$prec_mes,when=c(&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;),origin=&quot;1961-1-1&quot;) c_mes &lt;- continuity_ratio(data_gen,valmin=1.0) c_gen &lt;- continuity_ratio(data_mes,valmin=1.0) print(generation00_temp$var) plot_sample(vprec_mes,vprec_gen,sample=&quot;monthly&quot;,origin=origin,sort=TRUE,legend_position = &quot;topright&quot;,gray=TRUE,xlab = &quot;mes&quot;,ylab = &quot;sim&quot;) Results are again shown for the simulated precipitation time series for one elevation band. We consider them satisfactory. The seriality and normality test are both passed. 3.4.2.3 Simulating Future Daily Climate Using the insights from above, we can now generate future daily weather conditioned on the high resolution GCM output as described in the Section 3.4.1 above. For demonstration purposes, we generate a 10-year mid 21st century run and an end of 21st century run for both, the RCP 4.5 and RCP 8.5 concentration pathways. We start again with the specification of the parameters of the weather generator. # Random generator seed set.seed(123456) # Monthly climate is calculated if it is set to NULL PREC_CLIMATE &lt;- NULL # Calibration Period year_min &lt;- 1981 year_max &lt;- 2013 origin &lt;- &quot;1981-1-1&quot; # n GPCA iterations for variable and VAR residuals n_GPCA_iter &lt;- 0 n_GPCA_iteration_residuals &lt;- 0 n_GPCA_iter_prec &lt;- 0 n_GPCA_iteration_residuals_prec &lt;- 0 # Autoregressive order (p) p &lt;- 1 # number of weather realizations nscenario &lt;- 2 # Multi-site stations station &lt;- STATION_NAMES Next, we specify the future climate and the simulation periods which will be used to condition the weather generator. For demonstration, we use data from a model of the Gunt river basin that includes Lake Yashikul in the upstream. The prepared monthly climate scenarios of this RS MINVERVE model can be found in this directory './data/AmuDarya/GuntYashikul/ClimateProjections/'. Since RMAWGEN requires precipitation, mean minimum and mean maximum temperature on a monthly basis, these data are prepared below. # Simulation periods year_min_sim_51_60 &lt;- 2051 year_max_sim_51_60 &lt;- 2060 year_min_sim_91_00 &lt;- 2091 year_max_sim_91_00 &lt;- 2100 basin_climScen_Path &lt;- &#39;./data/AmuDarya/GuntYashikul/ClimateProjections/&#39; load(file=paste0(basin_climScen_Path,&#39;climScen_monthly&#39;,&#39;.rda&#39;)) # loads all available climate scenarios for a basin # Precipitation (pr) projections ## MIROC5 Model mean_climate_prec_sim_RCP45_MIROC5_51_60 &lt;- downscaled_ClimPred_rcp45_MIROC5$pr %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_prec_sim_RCP85_MIROC5_51_60 &lt;- downscaled_ClimPred_rcp85_MIROC5$pr %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_prec_sim_RCP45_MIROC5_91_00 &lt;- downscaled_ClimPred_rcp45_MIROC5$pr %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_prec_sim_RCP85_MIROC5_91_00 &lt;- downscaled_ClimPred_rcp85_MIROC5$pr %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() ## ACCESS1_3 Model mean_climate_prec_sim_RCP45_ACCESS1_3_51_60 &lt;- downscaled_ClimPred_rcp45_ACCESS1_3$pr %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_prec_sim_RCP85_ACCESS1_3_51_60 &lt;- downscaled_ClimPred_rcp85_ACCESS1_3$pr %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_prec_sim_RCP45_ACCESS1_3_91_00 &lt;- downscaled_ClimPred_rcp45_ACCESS1_3$pr %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_prec_sim_RCP85_ACCESS1_3_91_00 &lt;- downscaled_ClimPred_rcp85_ACCESS1_3$pr %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() ## CMCC_CM mean_climate_prec_sim_RCP45_CMCC_CM_51_60 &lt;- downscaled_ClimPred_rcp45_CMCC_CM$pr %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_prec_sim_RCP85_CMCC_CM_51_60 &lt;- downscaled_ClimPred_rcp85_CMCC_CM$pr %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_prec_sim_RCP45_CMCC_CM_91_00 &lt;- downscaled_ClimPred_rcp45_CMCC_CM$pr %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_prec_sim_RCP85_CMCC_CM_91_00 &lt;- downscaled_ClimPred_rcp85_CMCC_CM$pr %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() # Mean minimum temperature (tasmin) projections ## MIROC5 mean_climate_tasmin_sim_RCP45_MIROC5_51_60 &lt;- downscaled_ClimPred_rcp45_MIROC5$tasmin %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmin_sim_RCP85_MIROC5_51_60 &lt;- downscaled_ClimPred_rcp85_MIROC5$tasmin %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmin_sim_RCP45_MIROC5_91_00 &lt;- downscaled_ClimPred_rcp45_MIROC5$tasmin %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmin_sim_RCP85_MIROC5_91_00 &lt;- downscaled_ClimPred_rcp85_MIROC5$tasmin %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() ## ACCESS1_3 mean_climate_tasmin_sim_RCP45_ACCESS1_3_51_60 &lt;- downscaled_ClimPred_rcp45_ACCESS1_3$tasmin %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmin_sim_RCP85_ACCESS1_3_51_60 &lt;- downscaled_ClimPred_rcp85_ACCESS1_3$tasmin %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmin_sim_RCP45_ACCESS1_3_91_00 &lt;- downscaled_ClimPred_rcp45_ACCESS1_3$tasmin %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmin_sim_RCP85_ACCESS1_3_91_00 &lt;- downscaled_ClimPred_rcp85_ACCESS1_3$tasmin %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() ## CMCC_CM mean_climate_tasmin_sim_RCP45_CMCC_CM_51_60 &lt;- downscaled_ClimPred_rcp45_CMCC_CM$tasmin %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmin_sim_RCP85_CMCC_CM_51_60 &lt;- downscaled_ClimPred_rcp85_CMCC_CM$tasmin %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmin_sim_RCP45_CMCC_CM_91_00 &lt;- downscaled_ClimPred_rcp45_CMCC_CM$tasmin %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmin_sim_RCP85_CMCC_CM_91_00 &lt;- downscaled_ClimPred_rcp85_CMCC_CM$tasmin %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() # Mean maximum temperature (tasmax) projections ## MIROC5 mean_climate_tasmax_sim_RCP45_MIROC5_51_60 &lt;- downscaled_ClimPred_rcp45_MIROC5$tasmax %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmax_sim_RCP85_MIROC5_51_60 &lt;- downscaled_ClimPred_rcp85_MIROC5$tasmax %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmax_sim_RCP45_MIROC5_91_00 &lt;- downscaled_ClimPred_rcp45_MIROC5$tasmax %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmax_sim_RCP85_MIROC5_91_00 &lt;- downscaled_ClimPred_rcp85_MIROC5$tasmax %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() ## ACCESS1_3 mean_climate_tasmax_sim_RCP45_ACCESS1_3_51_60 &lt;- downscaled_ClimPred_rcp45_ACCESS1_3$tasmax %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmax_sim_RCP85_ACCESS1_3_51_60 &lt;- downscaled_ClimPred_rcp85_ACCESS1_3$tasmax %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmax_sim_RCP45_ACCESS1_3_91_00 &lt;- downscaled_ClimPred_rcp45_ACCESS1_3$tasmax %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmax_sim_RCP85_ACCESS1_3_91_00 &lt;- downscaled_ClimPred_rcp85_ACCESS1_3$tasmax %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() ## CMCC_CM mean_climate_tasmax_sim_RCP45_CMCC_CM_51_60 &lt;- downscaled_ClimPred_rcp45_CMCC_CM$tasmax %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmax_sim_RCP85_CMCC_CM_51_60 &lt;- downscaled_ClimPred_rcp85_CMCC_CM$tasmax %&gt;% filter(year&gt;=year_min_sim_51_60 &amp; year&lt;= year_max_sim_51_60) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmax_sim_RCP45_CMCC_CM_91_00 &lt;- downscaled_ClimPred_rcp45_CMCC_CM$tasmax %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() mean_climate_tasmax_sim_RCP85_CMCC_CM_91_00 &lt;- downscaled_ClimPred_rcp85_CMCC_CM$tasmax %&gt;% filter(year&gt;=year_min_sim_91_00 &amp; year&lt;= year_max_sim_91_00) %&gt;% dplyr::select(-c(&#39;month&#39;,&#39;day&#39;,&#39;year&#39;)) %&gt;% as.matrix() These files, stored as matrices contain the monthly climate scenarios where rows are month year combinations and columns are the data of the individual subcatchments. We are now ready to compute 12 precipitation and temperature scenarios, i.e. 2 for each RCP, 3 for each climate model and 2 for each of the periods of interest, 2051 - 2060 and 2091-2100. 3.4.2.4 Downscaling to Hourly Data If you download these data, it is advisable to maintain the directory structure as given via the Dropbox link. Please note that the entire directory is 4.79 GB of data.↩︎ "],["snow-cover-data.html", "3.5 Snow Cover Data", " 3.5 Snow Cover Data Section is work in progress! Stay tuned. "]]
